#======================================
# file name:python17.py
# author:liangliangSu
# date of writing:2022-09-17 18:47
#======================================
#!/usr/bin/env python3
#Python3 函数
#函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
#函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。
#定义一个函数
#你可以定义一个由自己想要功能的函数，以下是简单的规则：
#函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。
#任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
#函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
#函数内容以冒号 : 起始，并且缩进。
#return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。
#语法
#Python 定义函数使用 def 关键字，一般格式如下：
#def 函数名（参数列表）:
#    函数体
#默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。
#实例
#让我们使用函数来输出"Hello World！"：
##!/usr/bin/python3
#def hello() :
#    print("Hello World!")
#hello()
#更复杂点的应用，函数中带上参数变量:
#实例(Python 3.0+)
#比较两个数，并返回较大的数:
print('① -----------------------------------------------------------')
#!/usr/bin/python3
def max(a, b):
    if a > b:
        return a
    else:
        return b
a = 4
b = 5
print(max(a, b))
#以上实例输出结果：
#实例(Python 3.0+)
#计算面积函数:
print('② -----------------------------------------------------------')
#!/usr/bin/python3
# 计算面积函数
def area(width, height):
    return width * height
def print_welcome(name):
    print("Welcome", name)
print_welcome("Runoob")
w = 4
h = 5
print("width =", w, " height =", h, " area =", area(w, h))
#以上实例输出结果：
#Welcome Runoob
#width = 4  height = 5  area = 20
#函数调用
#定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。
#这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。
#如下实例调用了 printme() 函数：
#实例(Python 3.0+)
print('③ ------------------------------------------------------------')
#!/usr/bin/python3
# 定义函数
def printme( str ):
   # 打印任何传入的字符串
   print (str)
   return
# 调用函数
printme("我要调用用户自定义函数!")
printme("再次调用同一函数")
#以上实例输出结果：
#我要调用用户自定义函数!
#再次调用同一函数
#参数传递
#在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：
#a=[1,2,3]
#a="Runoob"
#以上代码中，[1,2,3] 是 List 类型，"Runoob" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。
#可更改(mutable)与不可更改(immutable)对象
#在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
#不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。
#可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
#python 函数的参数传递：
#不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。
#可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响
#python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。
#python 传不可变对象实例
#通过 id() 函数来查看内存地址变化：
#实例(Python 3.0+)
print('④ -----------------------------------------------------------')
def change(a):
    print(id(a))   # 指向的是同一个对象
    a=10
    print(id(a))   # 一个新对象
a=1
print(id(a))
change(a)
#以上实例输出结果为：
#4379369136
#4379369136
#4379369424
#可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。
#传可变对象实例
#可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：
#实例(Python 3.0+)
print('⑤ -----------------------------------------------------------')
#!/usr/bin/python3
# 可写函数说明
def changeme( mylist ):
   "修改传入的列表"
   mylist.append([1,2,3,4])
   print ("函数内取值: ", mylist)
   return
# 调用changeme函数
mylist = [10,20,30]
changeme( mylist )
#print ("函数外取值: ", mylist)
#传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：
#函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
#函数外取值:  [10, 20, 30, [1, 2, 3, 4]]
#参数
#以下是调用函数时可使用的正式参数类型：
#必需参数
#关键字参数
#默认参数
#不定长参数
#必需参数
#必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。
#调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：
#实例(Python 3.0+)
print('⑥ -----------------------------------------------------------')
#!/usr/bin/python3
#可写函数说明
#def printme( str ):
#   "打印任何传入的字符串"
#   print (str)
#   return
## 调用 printme 函数，不加参数会报错
#printme()
#以上实例输出结果：
#Traceback (most recent call last):
#  File "test.py", line 10, in <module>
#    printme()
#TypeError: printme() missing 1 required positional argument: 'str'
#关键字参数
#关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。
#使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。
#以下实例在函数 printme() 调用时使用参数名：
#实例(Python 3.0+)
print('⑦ -----------------------------------------------------------')
#!/usr/bin/python3
#可写函数说明
def printstr( str ):
   "打印任何传入的字符串"
   print (str)
   return
#调用printme函数
printstr( str = "菜鸟教程")
#以上实例输出结果：
#菜鸟教程
#以下实例中演示了函数参数的使用不需要使用指定顺序：
#实例(Python 3.0+)
print('⑧ -----------------------------------------------------------')
#!/usr/bin/python3
#可写函数说明
def printinfo0( name, age ):
   "打印任何传入的字符串"
   print ("名字: ", name)
   print ("年龄: ", age)
   return
#调用printinfo0函数
printinfo0( age=50, name="runoob" )
#以上实例输出结果：
#名字:  runoob
#年龄:  50
#默认参数
#调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：
#实例(Python 3.0+)
print('⑨ -----------------------------------------------------------')
#!/usr/bin/python3
#可写函数说明
def printinfo1( name, age = 35 ):
   "打印任何传入的字符串"
   print ("名字: ", name)
   print ("年龄: ", age)
   return
#调用printinfo1函数
printinfo1( age=50, name="runoob" )
print(' ----------------------分割线--------------------------------')
printinfo1( name="runoob" )
#以上实例输出结果：
#名字:  runoob
#年龄:  50
#名字:  runoob
#年龄:  35
#不定长参数
#你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：
#def functionname([formal_args,] *var_args_tuple ):
#   "函数_文档字符串"
#   function_suite
#   return [expression]
#加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。
#实例(Python 3.0+)
print(' ----------------------分割线--------------------------------')
#!/usr/bin/python3
# 可写函数说明
def printinfo2( arg1, *vartuple ):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   print (vartuple)
# 调用printinfo2 函数
printinfo2( 70, 60, 50 )
#以上实例输出结果：
#输出: 
#70
#(60, 50)
#如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：
#实例(Python 3.0+)
print(' ----------------------分割线--------------------------------')
#!/usr/bin/python3
# 可写函数说明
def printinfo3( arg1, *vartuple ):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   for var in vartuple:
      print (var)
   return
# 调用printinfo3 函数
printinfo3( 10 )
printinfo3( 70, 60, 50 )
#以上实例输出结果：
#输出:
#10
#输出:
#70
#60
#50
#还有一种就是参数带两个星号 **基本语法如下：
#def functionname([formal_args,] **var_args_dict ):
#   "函数_文档字符串"
#   function_suite
#   return [expression]
#加了两个星号 ** 的参数会以字典的形式导入。
#实例(Python 3.0+)
print(' ----------------------分割线--------------------------------')
#!/usr/bin/python3
# 可写函数说明
def printinfo4( arg1, **vardict ):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   print (vardict)
# 调用printinfo4 函数
printinfo4(1, a=2,b=3)
#以上实例输出结果：
#输出: 
#{'a': 2, 'b': 3}
#声明函数时，参数中星号 * 可以单独出现，例如:
#def f(a,b,*,c):
#    return a+b+c
#如果单独出现星号 *，则星号 * 后的参数必须用关键字传入：
# keyword.kwlist
#['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
##>>> def f(a,b,*,c):
#...     return a+b+c
#... 
#>>> f(1,2,3)   # 报错
#Traceback (most recent call last):
#  File "<stdin>", line 1, in <module>
#TypeError: f() takes 2 positional arguments but 3 were given
#>>> f(1,2,c=3) # 正常
#>>>
#匿名函数
#Python 使用 lambda 来创建匿名函数。
#所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。
#lambda 只是一个表达式，函数体比 def 简单很多。
#lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。
#lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
#虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。
#语法
#lambda 函数的语法只包含一个语句，如下：
#lambda [arg1 [,arg2,.....argn]]:expression
#设置参数 a 加上 10:
#实例
#x = lambda a : a + 10
#print(x(5))
#以上实例输出结果：
#15
#以下实例匿名函数设置两个参数：
#实例(Python 3.0+)
print(' ----------------------分割线--------------------------------')
#!/usr/bin/python3
# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2
pro = lambda arg1, arg2: arg1 * arg2
# 调用sum函数
print ("相加后的值为 : ", sum( 10, 20 ))
print ("相加后的值为 : ", sum( 20, 20 ))
print ("相乘后的值为 : ", pro( 20, 20 ))
print ("相乘后的值为 : ", pro( 20, 20 ))
#以上实例输出结果：
#相加后的值为 :  30
#相加后的值为 :  40
#我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。
#以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：
#实例
print(' ----------------------分割线--------------------------------')
def myfunc(n):
    return lambda a : a * n
mydoubler = myfunc(2)
mytripler = myfunc(3)
print(mydoubler(11))
print(mytripler(11))
#以上实例输出结果：
#22
#33
#return 语句
#return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：
#实例(Python 3.0+)
print(' ----------------------分割线--------------------------------')
#!/usr/bin/python3
# 可写函数说明
def sum2( arg1, arg2 ):
   # 返回2个参数的和."
   total = arg1 + arg2
   print ("函数内 : ", total)
   return total
# 调用sum2函数
total = sum2( 10, 20 )
print ("函数外 : ", total)
#以上实例输出结果：
#函数内 :  30
#函数外 :  30
#强制位置参数
#Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。
#在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:
print(' ----------------------分割线--------------------------------')
def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
#以下使用方法是正确的:
f(10, 20, 30, d=40, e=50, f=60)
f(10, 20, 30, 40, e=50, f=60)
f(10, 20, c=30,d=40, e=50, f=60)
#以下使用方法会发生错误:
#f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
#f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
# **************************************************************************************

# **************************************************************************************
#!/usr/bin/python3
#======================================
# file name:functionbase.sh
# author:liangliangSu
# date of writing:2022-09-24 17:57
#======================================
#一、函数简介
#函数(function)：可以用来保存代码，在需要时，对这些代码进行重复的调用
#总结函数的优点：
#1.遇到重复功能的时候，直接调用即可，减少代码量
#2.提升代码，项目的结构性，分工明确，提高代码可读性
#3.遇到扩展功能时，修改比较方便

#二、函数定义
#定义函数
'''
def 函数名(形参1,形参2...形参n):
    代码快
'''
#函数的命名规则和变量的命名规则一样
'''
1.由数字，字母，下划线组成
2.不能数字开头
3.不能用关键字
def fn():
    print("这是我的第一个函数")
'''
#三、函数调用
'''
语法
    函数名()
#函数必须遵守先定义再调用
def fn():
    print("这是我的第一个函数")
    print("hello")
    print("睡觉啦吗")
fn()
fn()
fn()
'''
#· fn是什么
#函数对象=》表示存代码的位置=》内存地址 本体
#· fn() 是什么
#调用函数
#· print 是什么
#函数对象
#· print() 是什么
#调用函数
#小练习
#定义一个login函数 功能是 输入用户名和密码，验证是否正确‍
def login():
    username = input("请输入用户名：")
    password = input("请输入密码：")
    if username == 'root' and password  == '123456':
        print("登录成功")
    else:
        print("用户名或密码错误，登录失败")
login()
#四、函数的参数
#1、形参和实参
#函数的参数
#在定义函数时，可以在函数名后()中定义数量不等的形参，多个形参之间使用 , 隔开
#形参(形式参数)
#定义形参就相当于在函数内部声明了变量，但是变量没有值
#实参(实际参数)
#在调用时候也必须传递实参，实参会赋值给对应位置的形参。

#定义函数时指定形参
def fn0(a,b):
    print("a =",a)
    print("b =",b)
#调用函数时，来传递实参
print('(1) -----------------------------------------------------------')
fn0(10,20)
print('(2) -----------------------------------------------------------')
fn0(666,333)

#总结：定义函数时的参数叫形参，调用的时候的参数叫实参定义了多少个形参就必须传递多少个实参
#2、默认值参数

#定义形参的时候可以为形参指定默认值
def fn1(a,b,c=10):
    print("a =",a)
    print("b =",b)
    print("c =",c)
print('(3) -----------------------------------------------------------')
fn1(1,2)     #如果不传递c,则采用默认值
print('(4) -----------------------------------------------------------')
fn1(1,2,3)   #如果传递了，优先使用用户传递的实参
#3、实参的传递方式
#3.1位置参数
#就是将对应位置的实参赋值给对应位置的形参
#位置参数缺点：需要记忆形参的位置的意思
#3.2关键字参数
#关键字参数：可以不按照形参定义的顺序来传递，而是根据参数名来传递参数
def fn2(a,b,c):
    print("a =",a)
    print("b =",b)
    print("c =",c)
print('(5) -----------------------------------------------------------')
fn2(b=1,c=3,a=2)    
#位置参数和关键字参数可以混合使用
print('(6) -----------------------------------------------------------')
fn2(1,2,c=20)    
#注意：介意混着，但是必须吧位置参数写 关键字参数前面

#4、实参的类型
#实参在传递的时候有没有类型的限制？
#· 函数调用不会限制你的类型，实参可以传递任意类型
#· 实参是可以任意一个数据类型，什么都行，啥都行

#5、可变参数
#5.1 args
#形参的前面加一个 * 号的参数就是可变参数，可以接收任意的位置参数，并且将所有的实参装到一个元组当中。
print('(7) -----------------------------------------------------------')
def fn3(*a):
    print("a =",a)
    print(type(a))
fn3(10,20,30,40,50,60,70,80,90,100)

def sum1(*a):        # *a 可以接受一切位置参数，并包装成一个元祖
    print(sum(a))   #a就是元组
sum1(1,2,3,4,5)
#无论传入几个参数，都会统一保存到一个元组当中，这个操作也可以称之为装包
#1.带 * 号的形参 只能有一个，因为你写多了就没法分
#2.带 * 号的形参可以和其他参数配合使用，但是得写在后面
print('(8) -----------------------------------------------------------')
def fn4(*args,b,c):
    print("a =",args)
    print("b =",b)
    print("c =",c)
fn4(1,2,3,4,5,6,7,8,9,10,20,30,b=4,c=3)    
#注意，平时取带*参数的名字的时候 一般是取args

#5.2 kwargs
#形参可以接收任意的 关键字参数，会将这些 参数统一保存到字典里，字典的键就是参数的名字，字典的值就是参数的值。
#· 注意：形参也是只能一个，并且必须写在所有参数最后。
#· 命名潜规则：kwargs
print('(9) -----------------------------------------------------------')
def fn5(**kwargs):
    print("kwargs =",kwargs)
    print(type(kwargs))
fn5(a=1,b=2,c=3)
#6、参数解包
print('(10)-----------------------------------------------------------')
def fn6(a,b,c,d):
    print("a =",a)
    print("b =",b)
    print("c =",c)
    print("d =",d)
t = [1,2,3,4]
#fn6(*t) # 传递实参时，可以在序列类型添加 * 号
fn6(*t)
#fn6(**d) # 传递实参时，可以在序列类型添加 * 号
def fn7(a,b,c):
    print("a =",a)
    print("b =",b)
    print("c =",c)
tuple = (10,20,30,)
print('(11)-----------------------------------------------------------')
fn7(*tuple)
dict = {"b":10,"a":20,"c":30}
print('(12)-----------------------------------------------------------')
fn7(**dict)

#五、函数返回值
#返回值：函数执行以后返回一个结果
#· 例如 f(x) = 2x + 1
#· f(2)的值是5
print('(13)-----------------------------------------------------------')
def fn8(x):
    return 2*x+1
print(fn8(2))
#python 可以通过 return 来指定函数的返回值，return 后是什么 函数返回值就是什么
#f(2)两个意思
#1.函数调用，会执行函数里面的代码
#2.本体还表示函数的返回值
#返回值可以是任意类型，包括函数
#None 代表空值 （N必须要大写）
#· 注意None千万不可以理解为0
#· 如果函数没有写reutrn， 返回None，表示空值
#总结：如果仅仅写一个reutrn 或者 不写return ，等价于 return
#None是python的特别的空值，用来代表空的
#在函数中 return 代表函数执行结束，后面代码不会执行。
#· break：退出整个循环
#· return : 结束函数
print('(14)-----------------------------------------------------------')
def f9(x):
    print(x)
    print(x + 1)
print(f9(6))
print('(15)-----------------------------------------------------------')
def f10(x):
    print(x)
    print(x + 1)
    print(x + 2)
print(f10(5))
print('(16) -----------------------------------------------------------')
def sum2(*args):
    result = 0
    for i in args:
          result +=1
          return result 
print(sum2(1,2,3,4,5))
#fn 和 fn()
#· print(fn) # 函数对象，打印fn就是打印函数对象地址 print(fn()) #
#· 调用函数，打印fn()其实就是在打印fn里面的返回值

#六、作用域
#1、作用域简介
#作用域直白来说就是产生作用的区域
#程序中就是：指的是变量生效的区域
print('(17) -----------------------------------------------------------')
x = 2
y = 3
def fn11():
    x = 1
    print("函数内部x =",x)
fn11()
print("函数外部x =",x)
print("函数外部y =",y)
#在Python作用域一共有2种
#1.全局作用域
#2.函数作用域

#2、全局作用域
#· 全局作用域：全局都有效
#· 全局作用域的生命周期：全局作用域在程序执行时创建了，在程序执行结束时候销毁
#· 所有函数以外的都是全局作用域
#· 在全局作用域中定义的变量，都属于全局变量，全局变量可以在程序的任意位置被访问
print('(18) -----------------------------------------------------------')
y = 2   #全局变量
def fn12():
    print("函数内部y =",y)
fn12()
print("函数外部y =",y)
#3、函数作用域
#函数作用域就是在函数内部函数作用域生命周期:函数作用域在函数调用时创建,在调用结束时销毁
print('(19) -----------------------------------------------------------')
def fn13():
    a = 10
    print("a =",a)
fn13()
fn13()
fn13()
print('(20) -----------------------------------------------------------')
a = 33
def fn():
    a = 10
    print("内部a =",a)
fn()    #调用函数返回函数内部值
print("外部a =",a)  #外部值（全局值）
#变量的使用规则：变量可以由内往外看，不能由外往里看
print('(21) -----------------------------------------------------------')
def fn14():
    a = 20
    def fn15():
        a = 10
        print(a)
    fn15()
fn14()
#使用变量的时候，会优先在当前作用域中寻找该变量，如果找到就使用，没有则继续往上一级作用域寻找。如果全局作用域都没有，则报错
#· 如果希望在函数中去修改全局变量
#· 可以使用 global 关键字来声明变量
print('(22) -----------------------------------------------------------')
a = 1
def fn16():
    global a    #声明在函数内部使用的a 是全局变量
    a = 2       #修改来全局变量中的a
fn16()
print(a)
#总结:
#1.变量里面能看外面的，但是外面不能看里面的
#2.如果局部修改全局变量可以加上一个global关键字

#七、命名空间
#1、介绍
#命名空间是指变量存储的位置，每个变量都需要存储到指定的命名空间中。

#2、分类：
#1、局部命名空间(local)：函数或类的方法的命名空间，它记录了函数的变量，包括函数的参数和局部定义的变量。
#2、闭包命名空间（enclosing function）：闭包函数 的名称空间（Python 3 引入）。
#3、全局命名空间(global)：每个模块自己的命名空间，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
#4、内置命名空间(builtin)：任何模块均可访问它，它存放着内置的函数和异常。

#3、查找顺序
#当一行代码要使用变量 x 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序：
#首先· 局部命名空间：
#特指当前函数或类的方法。如果函数定义了一个局部变量 x，或一个参数 x，Python 将使用它，然后停止搜索。
#第二· 全局命名空间：
#特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用它然后停止搜索。
#第三· 内置命名空间：
#对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。
#如果 Python 在这些名字空间找不到 x，它将放弃查找并引发一个 NameError 异常，如，NameError: name ‘aa’ is not defined。
#4、命名空间的生命周期
#不同的命名空间在不同的时刻创建，有不同的生存期。
#1、内置命名空间在 Python 解释器启动时创建，会一直保留，不被删除。
#2、模块的全局命名空间在模块定义被读入时创建，通常模块命名空间也会一直保存到解释器退出。
#3、当函数被调用时创建一个局部命名空间，当函数返回结果 或抛出异常时，被删除。每一个递归调用的函数都拥有自己的命名空间。
